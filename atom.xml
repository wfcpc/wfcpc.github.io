<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wfcpc.github.io</id>
    <title>Gridea</title>
    <updated>2020-12-18T10:39:43.408Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wfcpc.github.io"/>
    <link rel="self" href="https://wfcpc.github.io/atom.xml"/>
    <subtitle>æ¸©æ•…è€ŒçŸ¥æ–°</subtitle>
    <logo>https://wfcpc.github.io/images/avatar.png</logo>
    <icon>https://wfcpc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Arm64 Inline Hook]]></title>
        <id>https://wfcpc.github.io/post/arm64-inline-hook/</id>
        <link href="https://wfcpc.github.io/post/arm64-inline-hook/">
        </link>
        <updated>2020-11-25T05:26:46.000Z</updated>
        <content type="html"><![CDATA[<p>`int ret_value=0;<br>
///æ„å»ºè·å–å¯„å­˜å™¨è¾“å…¥çš„å€¼<br>
void * X0=NULL;<br>
void * X1=NULL;<br>
void * X2=NULL;<br>
void * X3=NULL;<br>
void * X4=NULL;<br>
void *RETVALUE=NULL;<br>
void getRegisters(uint64_t x0,uint64_t x1,uint64_t x2,uint64_t x3,uint64_t x4)<br>
{<br>
static uint64_t arg1=x0;<br>
static uint64_t arg2=x1;<br>
static uint64_t arg3=x2;<br>
static uint64_t arg4=x3;<br>
static uint64_t arg5=x4;<br>
X0=(void *)&amp;arg1;<br>
X1=(void *)&amp;arg2;<br>
X2=(void *)&amp;arg3;<br>
X3=(void *)&amp;arg4;<br>
X4=(void <em>)&amp;arg5;<br>
}<br>
///<br>
uint64_t setRegisters(void * address,uint64_t x0,uint64_t x1,uint64_t x2,uint64_t x3,uint64_t x4)<br>
{<br>
x0=</em>(uint64_t <em>)X0;<br>
x1=</em>(uint64_t <em>)X1;<br>
x2=</em>(uint64_t <em>)X2;<br>
x3=</em>(uint64_t <em>)X3;<br>
x4=</em>(uint64_t *)X4;<br>
#if defined(<strong>aarch64</strong>)<br>
LOGI(&quot;defined __aarch64 __ running&quot;);<br>
<strong>asm</strong>(&quot;ldr x0,[sp,#0x28]&quot;);<br>
<strong>asm</strong>(&quot;ldr x1,[sp,#0x20]&quot;);<br>
<strong>asm</strong>(&quot;ldr x2,[sp,#0x18]&quot;);<br>
<strong>asm</strong>(&quot;ldr x3,[sp,#0x10]&quot;);<br>
<strong>asm</strong>(&quot;ldr x4,[sp,#0x8]&quot;);<br>
<strong>asm</strong>(&quot;add sp,sp,#0x40&quot;);<br>
<strong>asm</strong>(&quot;mov x16,x0&quot;);<br>
uint64_t addr=(uint64_t)address;<br>
<strong>asm</strong>(&quot;mov x17,x0&quot;);<br>
<strong>asm</strong>(&quot;mov x0,x16&quot;);<br>
<strong>asm</strong>(&quot;ldp x29,x30,[sp],#0x50&quot;);<br>
<strong>asm</strong>(&quot;blr x17&quot;);<br>
<strong>asm</strong>(&quot;ret&quot;);<br>
#endif<br>
}</p>
<p>uint64_t (*template_func)();<br>
void getRetRegister(uint64_t x0)<br>
{<br>
static uint64_t ret_value=x0;<br>
RETVALUE=(void *)&amp;ret_value;<br>
}<br>
uint64_t getRetValue()<br>
{<br>
return <em>(uint64_t</em>)RETVALUE;<br>
}</p>
<p>class Space<br>
{<br>
public:<br>
uint64_t *array;<br>
int count=0;<br>
unsigned int lenght;<br>
Space(unsigned int len)<br>
{<br>
this-&gt;lenght=len;<br>
array=(uint64_t *)malloc(sizeof(uint64_t)*len);<br>
}</p>
<pre><code>void emit(uint64_t code)
{
    array[this-&gt;count++]=code;
}
void emitAtAddress(uint64_t *address)
{
    for(int i=0;i&lt;lenght;i++)
    {
        address[i]=array[i];
    }
}
uint64_t *getCodeAddress()
{
    return (uint64_t *)array;
}
</code></pre>
<p>};<br>
uint64_t backup_codes[4]={0};<br>
//uint64_t trampoline[100]={0};<br>
int num=0;<br>
enum registers<br>
{<br>
q0=0,<br>
q1=1,<br>
q2=2,<br>
q3=3,<br>
q4=4,<br>
q5=5,<br>
q6=6,<br>
q7=7,<br>
q8=8,<br>
q9=9,<br>
q10=10,<br>
q11=11,<br>
q12=12,<br>
q13=13,<br>
q14=14,<br>
q15=15,<br>
x0=0,<br>
x1=1,<br>
x2=2,<br>
x3=3,<br>
x4=4,<br>
x5=5,<br>
x6=6,<br>
x7=7,<br>
x8=8,<br>
x9=9,<br>
x10=10,<br>
x11=11,<br>
x12=12,<br>
x13=13,<br>
x14=14,<br>
x15=15,<br>
x16=16,<br>
x17=17,<br>
x18=18,<br>
x19=19,<br>
x20=20,<br>
x21=21,<br>
x22=22,<br>
x23=23,<br>
x24=24,<br>
x25=25,<br>
x26=26,<br>
x27=27,<br>
x28=28,<br>
fp=29,//fp<br>
lr=30,//lr<br>
sp=31,<br>
};<br>
uint64_t stp(int8_t imm, enum registers rt2, enum registers rn, enum registers rt1, bool x64Ins);<br>
void emit(uint64_t code);<br>
void insertOffset(bool* boo, int number, int pos, int width, bool x64Ins);<br>
void insertReg(bool* boo, enum registers register_, int pos);<br>
uint64_t binToCode(bool* boo);<br>
void insertDec(bool * boo,int number,int pos,int width);<br>
uint64_t add(uint16_t imm,enum registers rn,enum registers rd);<br>
uint64_t sub(uint16_t imm,enum registers rn,enum registers rd);<br>
uint64_t movX16NZCV();<br>
uint64_t movNZCVX16();<br>
uint64_t mov(uint16_t imm,enum registers rn,enum registers rd,bool x64Ins);<br>
uint64_t ldrImmi(uint32_t offset, enum registers rt, bool x64Ins);<br>
uint64_t br(enum registers rn);<br>
uint64_t  blr(enum registers rn);<br>
uint64_t ldp(int8_t imm,enum registers rt2,enum registers rn,enum registers rt1,bool x64Ins);<br>
uint64_t ret();<br>
void Save_codes(void *address);<br>
void BuildTrampoline(Space t,uint64_t * before_addr,uint64_t *after_addr);<br>
void BuildBeforeFunc(Space before,uint64_t * addr1,uint64_t * addr2,uint64_t *addr3);<br>
void hookfun(Space func,uint64_t *address_1);<br>
void BuildAfterFunc(Space after,uint64_t * addr1,uint64_t * addr2);<br>
void wfcpc_arm64_inline_hook(void *address, void *replace, void **backup)<br>
{<br>
//template_func=getRetT;<br>
template_func=getRetValue;<br>
auto *t_a=(void **)&amp;template_func;<br>
auto *t_b=*t_a;<br>
auto *b_a=*backup;<br>
b_a=t_b;<br>
//init<br>
Save_codes(address);</p>
<pre><code>Space func(8);
Space t(100);//è·³æ¿
uint64_t *t_addr=t.getCodeAddress();
Space before(100);
uint64_t *before_addr=before.getCodeAddress();
Space after(100);
uint64_t *after_addr=after.getCodeAddress();
hookfun(func,t_addr);//
func.emitAtAddress((uint64_t *)address);

BuildTrampoline(t,before_addr,after_addr);//æ„å»ºè·³æ¿

uint64_t *beforeAddr1=(uint64_t *)getRegisters;
uint64_t *beforeAddr2=t.getCodeAddress()+0xC;
uint64_t *beforeAddr3=(uint64_t *)address+0x14;
BuildBeforeFunc(before,beforeAddr1,beforeAddr2,beforeAddr3);//æ„å»ºhookå‡½æ•°æ‰§è¡Œå‰
//setRegisters
uint64_t *afterAddr1=(uint64_t *)getRetRegister;
uint64_t *afterAddr2=(uint64_t *)setRegisters;
BuildAfterFunc(after,afterAddr1,afterAddr2);//æ„å»ºhookå‡½æ•°æ‰§è¡Œå
</code></pre>
<p>}<br>
void Save_codes(void *address)<br>
{<br>
uint64_t *code_addr=(uint64_t *)address;<br>
for(int i=0;i&lt;4;i++)<br>
{<br>
backup_codes[i]=code_addr[i];<br>
}<br>
}<br>
void hookfun(Space func,uint64_t *address_1)<br>
{<br>
//func.emit(stp(-0x20,x17,sp,x16,false));//å…¥æ ˆx16,x17 sp-0x10<br>
func.emit(ldrImmi(2,x16,true));<br>
func.emit(br(x16));<br>
func.emit((uint64_t)address_1);//before hook stub address</p>
<pre><code>//func.emit(ldp(-0x10,x17,sp,x16,false));
//24å­—èŠ‚
//arm64 è°ƒè¯•æ™®é€šç¨‹åº å°è¯•é€šè¿‡retè¿”å›ï¼Œè¿”å›åˆ°åŸç¨‹åºåœ°å€
</code></pre>
<p>}<br>
void BuildTrampoline(Space t,uint64_t * before_addr,uint64_t *after_addr)<br>
{<br>
t.emit(ldrImmi(2,x16,true));<br>
t.emit(br(x16));<br>
t.emit(uint64_t(before_addr));//jmp before</p>
<pre><code>//ä¿å­˜x16,x17,æ¢å¤lr

t.emit(ldp(0x0,lr,sp,x16, false));
t.emit(add(0x10,sp,sp));
//spæ¢å¤å®Œå…¨æ­£å¸¸
t.emit(ldrImmi(2,x16,true));
t.emit(br(x16));
t.emit(uint64_t(after_addr));
</code></pre>
<p>}<br>
void BuildAfterFunc(Space after,uint64_t * addr1,uint64_t * addr2)<br>
{</p>
<pre><code>after.emit(movX16NZCV());
after.emit(sub(0xf0,sp,sp));

after.emit(stp(0x0,x1,sp,x1, false));//warning for x0
after.emit(stp(0x10,x3,sp,x2, false));
after.emit(stp(0x20,x5,sp,x4, false));
after.emit(stp(0x30,x7,sp,x6, false));
after.emit(stp(0x40,x9,sp,x8, false));
after.emit(stp(0x50,x11,sp,x10, false));
after.emit(stp(0x60,x13,sp,x12, false));
after.emit(stp(0x70,x15,sp,x14, false));
after.emit(stp(0x80,x18,sp,x16, false));
after.emit(stp(0x90,x20,sp,x19, false));
after.emit(stp(0xA0,x22,sp,x21, false));
after.emit(stp(0xB0,x24,sp,x23, false));
after.emit(stp(0xC0,x26,sp,x25, false));
after.emit(stp(0xD0,x28,sp,x27, false));
after.emit(stp(0xE0, lr, sp, fp, false));

after.emit(sub(0x80,sp,sp));

after.emit(stp(0x00,q1,sp,q0,true));
after.emit(stp(0x20,q3,sp,q2,true));
after.emit(stp(0x40,q5,sp,q4,true));
after.emit(stp(0x60,q7,sp,q6,true));

after.emit(ldrImmi(27,x16,true));
after.emit(blr(x16));
after.emit(ldrImmi(27,x16,true));
after.emit(blr(x16));

after.emit(ldp(0x00,q1,sp,q0,true));
after.emit(ldp(0x20,q3,sp,q2,true));
after.emit(ldp(0x40,q5,sp,q4,true));
after.emit(ldp(0x60,q7,sp,q6,true));

after.emit(add(0x80,sp,sp));

after.emit(ldp(0x0,x1,sp,x1, false));//warning for x0
after.emit(ldp(0x10,x3,sp,x2, false));
after.emit(ldp(0x20,x5,sp,x4, false));
after.emit(ldp(0x30,x7,sp,x6, false));
after.emit(ldp(0x40,x9,sp,x8, false));
after.emit(ldp(0x50,x11,sp,x10, false));
after.emit(ldp(0x60,x13,sp,x12, false));
after.emit(ldp(0x70,x15,sp,x14, false));
after.emit(ldp(0x80,x18,sp,x16, false));
after.emit(ldp(0x90,x20,sp,x19, false));
after.emit(ldp(0xA0,x22,sp,x21, false));
after.emit(ldp(0xB0,x24,sp,x23, false));
after.emit(ldp(0xC0,x26,sp,x25, false));
after.emit(ldp(0xD0,x28,sp,x27, false));
after.emit(ldp(0xE0, lr, sp, fp, false));

after.emit(add(0xf0,sp,sp));

after.emit(movNZCVX16());
//after.emit(add(0x10,sp,sp));
after.emit(ret());
after.emit(uint64_t(addr1));//getRet
after.emit(uint64_t(addr2));//after func address
</code></pre>
<p>}<br>
void BuildBeforeFunc(Space before,uint64_t * addr1,uint64_t * addr2,uint64_t *addr3)<br>
{<br>
//before.emit(sub(0x20,sp,sp));<br>
before.emit(movX16NZCV());</p>
<pre><code>before.emit(sub(0xf0,sp,sp));

before.emit(stp(0x0,x1,sp,x0, false));
before.emit(stp(0x10,x3,sp,x2, false));
before.emit(stp(0x20,x5,sp,x4, false));
before.emit(stp(0x30,x7,sp,x6, false));
before.emit(stp(0x40,x9,sp,x8, false));
before.emit(stp(0x50,x11,sp,x10, false));
before.emit(stp(0x60,x13,sp,x12, false));
before.emit(stp(0x70,x15,sp,x14, false));
before.emit(stp(0x80,x18,sp,x16, false));
before.emit(stp(0x90,x20,sp,x19, false));
before.emit(stp(0xA0,x22,sp,x21, false));
before.emit(stp(0xB0,x24,sp,x23, false));
before.emit(stp(0xC0,x26,sp,x25, false));
before.emit(stp(0xD0,x28,sp,x27, false));
before.emit(stp(0xE0, lr, sp, fp, false));

before.emit(sub(0x80,sp,sp));

before.emit(stp(0x00,q1,sp,q0,true));
before.emit(stp(0x20,q3,sp,q2,true));
before.emit(stp(0x40,q5,sp,q4,true));
before.emit(stp(0x60,q7,sp,q6,true));

before.emit(mov(0,sp,x17,false));

before.emit(ldrImmi(29,x16,true));
before.emit(blr(x16));

before.emit(ldp(0x00,q1,sp,q0,true));
before.emit(ldp(0x20,q3,sp,q2,true));
before.emit(ldp(0x40,q5,sp,q4,true));
before.emit(ldp(0x60,q7,sp,q6,true));

before.emit(add(0x80,sp,sp));

before.emit(ldp(0x0,x1,sp,x0, false));
before.emit(ldp(0x10,x3,sp,x2, false));
before.emit(ldp(0x20,x5,sp,x4, false));
before.emit(ldp(0x30,x7,sp,x6, false));
before.emit(ldp(0x40,x9,sp,x8, false));
before.emit(ldp(0x50,x11,sp,x10, false));
before.emit(ldp(0x60,x13,sp,x12, false));
before.emit(ldp(0x70,x15,sp,x14, false));
before.emit(ldp(0x80,x18,sp,x16, false));
before.emit(ldp(0x90,x20,sp,x19, false));
before.emit(ldp(0xA0,x22,sp,x21, false));
before.emit(ldp(0xB0,x24,sp,x23, false));
before.emit(ldp(0xC0,x26,sp,x25, false));
before.emit(ldp(0xD0,x28,sp,x27, false));
before.emit(ldp(0xE0, lr, sp, fp, false));

before.emit(add(0xf0,sp,sp));

before.emit(movNZCVX16());


before.emit(sub(0x10,sp,sp));
before.emit(stp(0,lr,sp,x0,false));//x0å’Œlrå…¥æ ˆä¿å­˜åŸç¨‹åºè¿”å›åœ°å€
//æ­¤æ—¶æ ˆä¸­ä¿å­˜è¿™æœ€å¼€å§‹ä¿å­˜çš„x16,x17
//åˆšåˆšå…¥æ ˆçš„x0å’Œlr
//lr x0 &lt;&lt;------sp_now-0x10

before.emit(ldrImmi(5,lr,true));
before.emit(ldrImmi(6,x16, true));
before.emit(br(x16));//29
before.emit((uint64_t)addr1);//addr to before func
before.emit((uint64_t)addr2);//save lr to after
before.emit((uint64_t)addr3);//address back to program+offset
</code></pre>
<p>}<br>
uint64_t ret()<br>
{<br>
return 0xC0035FD6;<br>
}<br>
uint64_t  blr(enum registers rn)<br>
{<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=1;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=1;
ans[i++]=1;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
ans[i++]=1;
ans[i++]=1;

ans[i++]=1;
ans[i++]=1;
ans[i++]=1;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
insertReg(ans,rn,26);
i=27;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
</code></pre>
<p>}<br>
uint64_t br(enum registers rn)<br>
{<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=1;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=1;
ans[i++]=1;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=1;
ans[i++]=1;
ans[i++]=1;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
insertReg(ans,rn,26);
i=27;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t ldrImmi(uint32_t offset, enum registers rt, bool x64Ins)<br>
{<br>
int immi=int(offset);<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=0;<br>
ans[i++]=x64Ins;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=1;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
insertDec(ans,immi,26,19);
insertReg(ans,rt,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t mov(uint16_t imm,enum registers rn,enum registers rd,bool x64Ins)<br>
{<br>
int immi=int(imm);<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=x64Ins;<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t movX16NZCV()<br>
{<br>
return 0x10423BD5;<br>
}<br>
uint64_t movNZCVX16()<br>
{<br>
return 0x10421BD5;<br>
}<br>
uint64_t add(uint16_t imm,enum registers rn,enum registers rd)<br>
{<br>
bool sf=1,sh=0;<br>
int immi=int(imm);<br>
bool ans[32] = {0};<br>
int i=0;<br>
ans[i++]=sf;<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=sh;

insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t sub(uint16_t imm,enum registers rn,enum registers rd)<br>
{<br>
bool sf=1,sh=0;<br>
int immi=int(imm);<br>
bool ans[32] = {0};<br>
int i=0;<br>
ans[i++]=sf;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=sh;

insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t stp(int8_t imm, enum registers rt2, enum registers rn, enum registers rt1, bool x64Ins)<br>
{<br>
int immi = int(imm);<br>
bool ans[32] = {0};<br>
int i = 0;<br>
if (x64Ins)<br>
{<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
}<br>
else<br>
{</p>
<pre><code>    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 1;
    ans[i++] = 0;
}
insertOffset(ans, immi, 16, 7, x64Ins);
insertReg(ans,rt2,21);
insertReg(ans, rn, 26);
insertReg(ans, rt1, 31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t ldp(int8_t imm,enum registers rt2,enum registers rn,enum registers rt1,bool x64Ins)<br>
{<br>
int immi = int(imm);<br>
bool ans[32] = {0};<br>
int i = 0;<br>
if(x64Ins)<br>
ans[i++]=1;<br>
else<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;<br>
ans[i++]=0;</p>
<pre><code>ans[i++]=1;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=1;
ans[i++]=1;

insertOffset(ans,immi,16,7,x64Ins);
insertReg(ans,rt2,21);
insertReg(ans,rn,26);
insertReg(ans,rt1,31);
return binToCode(ans);
</code></pre>
<p>}<br>
void insertOffset(bool* boo, int number, int pos, int width, bool x64Ins)<br>
{<br>
if (number &gt; 0)<br>
{<br>
number = number / 16;<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
}<br>
else<br>
{<br>
number = abs(number);<br>
number = number / 16;<br>
if (!x64Ins)<br>
{<br>
number <em>= 2;<br>
}<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
boo[pos-width+1] = 1;<br>
for (int j = pos-width+2; j &lt;=pos; j++)<br>
boo[j] = boo[j] == 1 ? 0 : 1;<br>
bool up = true;<br>
for (int j = pos; j &gt; pos-width+1; j--)<br>
{<br>
if (boo[j] == 1 &amp;&amp; up)<br>
{<br>
up = true;<br>
boo[j] = 0;<br>
}<br>
else if (boo[j] == 0 &amp;&amp; up)<br>
{<br>
up = false;<br>
boo[j] = 1;<br>
}<br>
if (!up)<br>
break;<br>
}<br>
}<br>
}<br>
void insertDec(bool * boo,int number,int pos,int width)<br>
{<br>
if (number &gt; 0)<br>
{<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
}<br>
else<br>
{<br>
number = abs(number);<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
boo[pos-width+1] = 1;<br>
for (int j = pos-width+2; j &lt;=pos; j++)<br>
boo[j] = boo[j] == 1 ? 0 : 1;<br>
bool up = true;<br>
for (int j = pos; j &gt; pos-width+1; j--)<br>
{<br>
if (boo[j] == 1 &amp;&amp; up)<br>
{<br>
up = true;<br>
boo[j] = 0;<br>
}<br>
else if (boo[j] == 0 &amp;&amp; up)<br>
{<br>
up = false;<br>
boo[j] = 1;<br>
}<br>
if (!up)<br>
break;<br>
}<br>
}<br>
}<br>
void insertReg(bool</em> boo, enum registers register_, int pos)<br>
{<br>
int reg=int(register_);<br>
int loop = 5;<br>
while (loop != 0 &amp;&amp; reg != 0)<br>
{<br>
boo[pos--] = reg % 2;<br>
reg /= 2;<br>
loop--;<br>
}<br>
}<br>
uint64_t binToCode(bool* boo)<br>
{</p>
<pre><code>for (int i = 0; i &lt; 2; i++)
{
    for (int j = 0; j &lt; 8; j++)
    {
        bool temp = boo[i * 8 + j];
        boo[i * 8 + j] = boo[31 - 8 * i - (7 - j)];
        boo[31 - 8 * i - (7 - j)] = temp;
    }
}
uint64_t result = 0;
int times = 0;
for (int i = 31; i &gt;= 0; i--)
{
    result = result + boo[i] * uint64_t(pow(2, times));
    times++;
}
return result;
</code></pre>
<p>}`</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://wfcpc.github.io/post/hello-gridea/</id>
        <link href="https://wfcpc.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>Windows</strong>ï¼Œ<strong>MacOS</strong> æˆ– <strong>Linux</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>