<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wfcpc.github.io</id>
    <title>Gridea</title>
    <updated>2020-12-18T10:39:43.408Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wfcpc.github.io"/>
    <link rel="self" href="https://wfcpc.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wfcpc.github.io/images/avatar.png</logo>
    <icon>https://wfcpc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Arm64 Inline Hook]]></title>
        <id>https://wfcpc.github.io/post/arm64-inline-hook/</id>
        <link href="https://wfcpc.github.io/post/arm64-inline-hook/">
        </link>
        <updated>2020-11-25T05:26:46.000Z</updated>
        <content type="html"><![CDATA[<p>`int ret_value=0;<br>
///构建获取寄存器输入的值<br>
void * X0=NULL;<br>
void * X1=NULL;<br>
void * X2=NULL;<br>
void * X3=NULL;<br>
void * X4=NULL;<br>
void *RETVALUE=NULL;<br>
void getRegisters(uint64_t x0,uint64_t x1,uint64_t x2,uint64_t x3,uint64_t x4)<br>
{<br>
static uint64_t arg1=x0;<br>
static uint64_t arg2=x1;<br>
static uint64_t arg3=x2;<br>
static uint64_t arg4=x3;<br>
static uint64_t arg5=x4;<br>
X0=(void *)&amp;arg1;<br>
X1=(void *)&amp;arg2;<br>
X2=(void *)&amp;arg3;<br>
X3=(void *)&amp;arg4;<br>
X4=(void <em>)&amp;arg5;<br>
}<br>
///<br>
uint64_t setRegisters(void * address,uint64_t x0,uint64_t x1,uint64_t x2,uint64_t x3,uint64_t x4)<br>
{<br>
x0=</em>(uint64_t <em>)X0;<br>
x1=</em>(uint64_t <em>)X1;<br>
x2=</em>(uint64_t <em>)X2;<br>
x3=</em>(uint64_t <em>)X3;<br>
x4=</em>(uint64_t *)X4;<br>
#if defined(<strong>aarch64</strong>)<br>
LOGI(&quot;defined __aarch64 __ running&quot;);<br>
<strong>asm</strong>(&quot;ldr x0,[sp,#0x28]&quot;);<br>
<strong>asm</strong>(&quot;ldr x1,[sp,#0x20]&quot;);<br>
<strong>asm</strong>(&quot;ldr x2,[sp,#0x18]&quot;);<br>
<strong>asm</strong>(&quot;ldr x3,[sp,#0x10]&quot;);<br>
<strong>asm</strong>(&quot;ldr x4,[sp,#0x8]&quot;);<br>
<strong>asm</strong>(&quot;add sp,sp,#0x40&quot;);<br>
<strong>asm</strong>(&quot;mov x16,x0&quot;);<br>
uint64_t addr=(uint64_t)address;<br>
<strong>asm</strong>(&quot;mov x17,x0&quot;);<br>
<strong>asm</strong>(&quot;mov x0,x16&quot;);<br>
<strong>asm</strong>(&quot;ldp x29,x30,[sp],#0x50&quot;);<br>
<strong>asm</strong>(&quot;blr x17&quot;);<br>
<strong>asm</strong>(&quot;ret&quot;);<br>
#endif<br>
}</p>
<p>uint64_t (*template_func)();<br>
void getRetRegister(uint64_t x0)<br>
{<br>
static uint64_t ret_value=x0;<br>
RETVALUE=(void *)&amp;ret_value;<br>
}<br>
uint64_t getRetValue()<br>
{<br>
return <em>(uint64_t</em>)RETVALUE;<br>
}</p>
<p>class Space<br>
{<br>
public:<br>
uint64_t *array;<br>
int count=0;<br>
unsigned int lenght;<br>
Space(unsigned int len)<br>
{<br>
this-&gt;lenght=len;<br>
array=(uint64_t *)malloc(sizeof(uint64_t)*len);<br>
}</p>
<pre><code>void emit(uint64_t code)
{
    array[this-&gt;count++]=code;
}
void emitAtAddress(uint64_t *address)
{
    for(int i=0;i&lt;lenght;i++)
    {
        address[i]=array[i];
    }
}
uint64_t *getCodeAddress()
{
    return (uint64_t *)array;
}
</code></pre>
<p>};<br>
uint64_t backup_codes[4]={0};<br>
//uint64_t trampoline[100]={0};<br>
int num=0;<br>
enum registers<br>
{<br>
q0=0,<br>
q1=1,<br>
q2=2,<br>
q3=3,<br>
q4=4,<br>
q5=5,<br>
q6=6,<br>
q7=7,<br>
q8=8,<br>
q9=9,<br>
q10=10,<br>
q11=11,<br>
q12=12,<br>
q13=13,<br>
q14=14,<br>
q15=15,<br>
x0=0,<br>
x1=1,<br>
x2=2,<br>
x3=3,<br>
x4=4,<br>
x5=5,<br>
x6=6,<br>
x7=7,<br>
x8=8,<br>
x9=9,<br>
x10=10,<br>
x11=11,<br>
x12=12,<br>
x13=13,<br>
x14=14,<br>
x15=15,<br>
x16=16,<br>
x17=17,<br>
x18=18,<br>
x19=19,<br>
x20=20,<br>
x21=21,<br>
x22=22,<br>
x23=23,<br>
x24=24,<br>
x25=25,<br>
x26=26,<br>
x27=27,<br>
x28=28,<br>
fp=29,//fp<br>
lr=30,//lr<br>
sp=31,<br>
};<br>
uint64_t stp(int8_t imm, enum registers rt2, enum registers rn, enum registers rt1, bool x64Ins);<br>
void emit(uint64_t code);<br>
void insertOffset(bool* boo, int number, int pos, int width, bool x64Ins);<br>
void insertReg(bool* boo, enum registers register_, int pos);<br>
uint64_t binToCode(bool* boo);<br>
void insertDec(bool * boo,int number,int pos,int width);<br>
uint64_t add(uint16_t imm,enum registers rn,enum registers rd);<br>
uint64_t sub(uint16_t imm,enum registers rn,enum registers rd);<br>
uint64_t movX16NZCV();<br>
uint64_t movNZCVX16();<br>
uint64_t mov(uint16_t imm,enum registers rn,enum registers rd,bool x64Ins);<br>
uint64_t ldrImmi(uint32_t offset, enum registers rt, bool x64Ins);<br>
uint64_t br(enum registers rn);<br>
uint64_t  blr(enum registers rn);<br>
uint64_t ldp(int8_t imm,enum registers rt2,enum registers rn,enum registers rt1,bool x64Ins);<br>
uint64_t ret();<br>
void Save_codes(void *address);<br>
void BuildTrampoline(Space t,uint64_t * before_addr,uint64_t *after_addr);<br>
void BuildBeforeFunc(Space before,uint64_t * addr1,uint64_t * addr2,uint64_t *addr3);<br>
void hookfun(Space func,uint64_t *address_1);<br>
void BuildAfterFunc(Space after,uint64_t * addr1,uint64_t * addr2);<br>
void wfcpc_arm64_inline_hook(void *address, void *replace, void **backup)<br>
{<br>
//template_func=getRetT;<br>
template_func=getRetValue;<br>
auto *t_a=(void **)&amp;template_func;<br>
auto *t_b=*t_a;<br>
auto *b_a=*backup;<br>
b_a=t_b;<br>
//init<br>
Save_codes(address);</p>
<pre><code>Space func(8);
Space t(100);//跳板
uint64_t *t_addr=t.getCodeAddress();
Space before(100);
uint64_t *before_addr=before.getCodeAddress();
Space after(100);
uint64_t *after_addr=after.getCodeAddress();
hookfun(func,t_addr);//
func.emitAtAddress((uint64_t *)address);

BuildTrampoline(t,before_addr,after_addr);//构建跳板

uint64_t *beforeAddr1=(uint64_t *)getRegisters;
uint64_t *beforeAddr2=t.getCodeAddress()+0xC;
uint64_t *beforeAddr3=(uint64_t *)address+0x14;
BuildBeforeFunc(before,beforeAddr1,beforeAddr2,beforeAddr3);//构建hook函数执行前
//setRegisters
uint64_t *afterAddr1=(uint64_t *)getRetRegister;
uint64_t *afterAddr2=(uint64_t *)setRegisters;
BuildAfterFunc(after,afterAddr1,afterAddr2);//构建hook函数执行后
</code></pre>
<p>}<br>
void Save_codes(void *address)<br>
{<br>
uint64_t *code_addr=(uint64_t *)address;<br>
for(int i=0;i&lt;4;i++)<br>
{<br>
backup_codes[i]=code_addr[i];<br>
}<br>
}<br>
void hookfun(Space func,uint64_t *address_1)<br>
{<br>
//func.emit(stp(-0x20,x17,sp,x16,false));//入栈x16,x17 sp-0x10<br>
func.emit(ldrImmi(2,x16,true));<br>
func.emit(br(x16));<br>
func.emit((uint64_t)address_1);//before hook stub address</p>
<pre><code>//func.emit(ldp(-0x10,x17,sp,x16,false));
//24字节
//arm64 调试普通程序 尝试通过ret返回，返回到原程序地址
</code></pre>
<p>}<br>
void BuildTrampoline(Space t,uint64_t * before_addr,uint64_t *after_addr)<br>
{<br>
t.emit(ldrImmi(2,x16,true));<br>
t.emit(br(x16));<br>
t.emit(uint64_t(before_addr));//jmp before</p>
<pre><code>//保存x16,x17,恢复lr

t.emit(ldp(0x0,lr,sp,x16, false));
t.emit(add(0x10,sp,sp));
//sp恢复完全正常
t.emit(ldrImmi(2,x16,true));
t.emit(br(x16));
t.emit(uint64_t(after_addr));
</code></pre>
<p>}<br>
void BuildAfterFunc(Space after,uint64_t * addr1,uint64_t * addr2)<br>
{</p>
<pre><code>after.emit(movX16NZCV());
after.emit(sub(0xf0,sp,sp));

after.emit(stp(0x0,x1,sp,x1, false));//warning for x0
after.emit(stp(0x10,x3,sp,x2, false));
after.emit(stp(0x20,x5,sp,x4, false));
after.emit(stp(0x30,x7,sp,x6, false));
after.emit(stp(0x40,x9,sp,x8, false));
after.emit(stp(0x50,x11,sp,x10, false));
after.emit(stp(0x60,x13,sp,x12, false));
after.emit(stp(0x70,x15,sp,x14, false));
after.emit(stp(0x80,x18,sp,x16, false));
after.emit(stp(0x90,x20,sp,x19, false));
after.emit(stp(0xA0,x22,sp,x21, false));
after.emit(stp(0xB0,x24,sp,x23, false));
after.emit(stp(0xC0,x26,sp,x25, false));
after.emit(stp(0xD0,x28,sp,x27, false));
after.emit(stp(0xE0, lr, sp, fp, false));

after.emit(sub(0x80,sp,sp));

after.emit(stp(0x00,q1,sp,q0,true));
after.emit(stp(0x20,q3,sp,q2,true));
after.emit(stp(0x40,q5,sp,q4,true));
after.emit(stp(0x60,q7,sp,q6,true));

after.emit(ldrImmi(27,x16,true));
after.emit(blr(x16));
after.emit(ldrImmi(27,x16,true));
after.emit(blr(x16));

after.emit(ldp(0x00,q1,sp,q0,true));
after.emit(ldp(0x20,q3,sp,q2,true));
after.emit(ldp(0x40,q5,sp,q4,true));
after.emit(ldp(0x60,q7,sp,q6,true));

after.emit(add(0x80,sp,sp));

after.emit(ldp(0x0,x1,sp,x1, false));//warning for x0
after.emit(ldp(0x10,x3,sp,x2, false));
after.emit(ldp(0x20,x5,sp,x4, false));
after.emit(ldp(0x30,x7,sp,x6, false));
after.emit(ldp(0x40,x9,sp,x8, false));
after.emit(ldp(0x50,x11,sp,x10, false));
after.emit(ldp(0x60,x13,sp,x12, false));
after.emit(ldp(0x70,x15,sp,x14, false));
after.emit(ldp(0x80,x18,sp,x16, false));
after.emit(ldp(0x90,x20,sp,x19, false));
after.emit(ldp(0xA0,x22,sp,x21, false));
after.emit(ldp(0xB0,x24,sp,x23, false));
after.emit(ldp(0xC0,x26,sp,x25, false));
after.emit(ldp(0xD0,x28,sp,x27, false));
after.emit(ldp(0xE0, lr, sp, fp, false));

after.emit(add(0xf0,sp,sp));

after.emit(movNZCVX16());
//after.emit(add(0x10,sp,sp));
after.emit(ret());
after.emit(uint64_t(addr1));//getRet
after.emit(uint64_t(addr2));//after func address
</code></pre>
<p>}<br>
void BuildBeforeFunc(Space before,uint64_t * addr1,uint64_t * addr2,uint64_t *addr3)<br>
{<br>
//before.emit(sub(0x20,sp,sp));<br>
before.emit(movX16NZCV());</p>
<pre><code>before.emit(sub(0xf0,sp,sp));

before.emit(stp(0x0,x1,sp,x0, false));
before.emit(stp(0x10,x3,sp,x2, false));
before.emit(stp(0x20,x5,sp,x4, false));
before.emit(stp(0x30,x7,sp,x6, false));
before.emit(stp(0x40,x9,sp,x8, false));
before.emit(stp(0x50,x11,sp,x10, false));
before.emit(stp(0x60,x13,sp,x12, false));
before.emit(stp(0x70,x15,sp,x14, false));
before.emit(stp(0x80,x18,sp,x16, false));
before.emit(stp(0x90,x20,sp,x19, false));
before.emit(stp(0xA0,x22,sp,x21, false));
before.emit(stp(0xB0,x24,sp,x23, false));
before.emit(stp(0xC0,x26,sp,x25, false));
before.emit(stp(0xD0,x28,sp,x27, false));
before.emit(stp(0xE0, lr, sp, fp, false));

before.emit(sub(0x80,sp,sp));

before.emit(stp(0x00,q1,sp,q0,true));
before.emit(stp(0x20,q3,sp,q2,true));
before.emit(stp(0x40,q5,sp,q4,true));
before.emit(stp(0x60,q7,sp,q6,true));

before.emit(mov(0,sp,x17,false));

before.emit(ldrImmi(29,x16,true));
before.emit(blr(x16));

before.emit(ldp(0x00,q1,sp,q0,true));
before.emit(ldp(0x20,q3,sp,q2,true));
before.emit(ldp(0x40,q5,sp,q4,true));
before.emit(ldp(0x60,q7,sp,q6,true));

before.emit(add(0x80,sp,sp));

before.emit(ldp(0x0,x1,sp,x0, false));
before.emit(ldp(0x10,x3,sp,x2, false));
before.emit(ldp(0x20,x5,sp,x4, false));
before.emit(ldp(0x30,x7,sp,x6, false));
before.emit(ldp(0x40,x9,sp,x8, false));
before.emit(ldp(0x50,x11,sp,x10, false));
before.emit(ldp(0x60,x13,sp,x12, false));
before.emit(ldp(0x70,x15,sp,x14, false));
before.emit(ldp(0x80,x18,sp,x16, false));
before.emit(ldp(0x90,x20,sp,x19, false));
before.emit(ldp(0xA0,x22,sp,x21, false));
before.emit(ldp(0xB0,x24,sp,x23, false));
before.emit(ldp(0xC0,x26,sp,x25, false));
before.emit(ldp(0xD0,x28,sp,x27, false));
before.emit(ldp(0xE0, lr, sp, fp, false));

before.emit(add(0xf0,sp,sp));

before.emit(movNZCVX16());


before.emit(sub(0x10,sp,sp));
before.emit(stp(0,lr,sp,x0,false));//x0和lr入栈保存原程序返回地址
//此时栈中保存这最开始保存的x16,x17
//刚刚入栈的x0和lr
//lr x0 &lt;&lt;------sp_now-0x10

before.emit(ldrImmi(5,lr,true));
before.emit(ldrImmi(6,x16, true));
before.emit(br(x16));//29
before.emit((uint64_t)addr1);//addr to before func
before.emit((uint64_t)addr2);//save lr to after
before.emit((uint64_t)addr3);//address back to program+offset
</code></pre>
<p>}<br>
uint64_t ret()<br>
{<br>
return 0xC0035FD6;<br>
}<br>
uint64_t  blr(enum registers rn)<br>
{<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=1;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=1;
ans[i++]=1;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
ans[i++]=1;
ans[i++]=1;

ans[i++]=1;
ans[i++]=1;
ans[i++]=1;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
insertReg(ans,rn,26);
i=27;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
</code></pre>
<p>}<br>
uint64_t br(enum registers rn)<br>
{<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=1;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=1;
ans[i++]=1;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=1;
ans[i++]=1;
ans[i++]=1;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
insertReg(ans,rn,26);
i=27;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t ldrImmi(uint32_t offset, enum registers rt, bool x64Ins)<br>
{<br>
int immi=int(offset);<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=0;<br>
ans[i++]=x64Ins;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=1;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
insertDec(ans,immi,26,19);
insertReg(ans,rt,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t mov(uint16_t imm,enum registers rn,enum registers rd,bool x64Ins)<br>
{<br>
int immi=int(imm);<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=x64Ins;<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t movX16NZCV()<br>
{<br>
return 0x10423BD5;<br>
}<br>
uint64_t movNZCVX16()<br>
{<br>
return 0x10421BD5;<br>
}<br>
uint64_t add(uint16_t imm,enum registers rn,enum registers rd)<br>
{<br>
bool sf=1,sh=0;<br>
int immi=int(imm);<br>
bool ans[32] = {0};<br>
int i=0;<br>
ans[i++]=sf;<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=sh;

insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t sub(uint16_t imm,enum registers rn,enum registers rd)<br>
{<br>
bool sf=1,sh=0;<br>
int immi=int(imm);<br>
bool ans[32] = {0};<br>
int i=0;<br>
ans[i++]=sf;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=sh;

insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t stp(int8_t imm, enum registers rt2, enum registers rn, enum registers rt1, bool x64Ins)<br>
{<br>
int immi = int(imm);<br>
bool ans[32] = {0};<br>
int i = 0;<br>
if (x64Ins)<br>
{<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
}<br>
else<br>
{</p>
<pre><code>    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 1;
    ans[i++] = 0;
}
insertOffset(ans, immi, 16, 7, x64Ins);
insertReg(ans,rt2,21);
insertReg(ans, rn, 26);
insertReg(ans, rt1, 31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t ldp(int8_t imm,enum registers rt2,enum registers rn,enum registers rt1,bool x64Ins)<br>
{<br>
int immi = int(imm);<br>
bool ans[32] = {0};<br>
int i = 0;<br>
if(x64Ins)<br>
ans[i++]=1;<br>
else<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;<br>
ans[i++]=0;</p>
<pre><code>ans[i++]=1;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=1;
ans[i++]=1;

insertOffset(ans,immi,16,7,x64Ins);
insertReg(ans,rt2,21);
insertReg(ans,rn,26);
insertReg(ans,rt1,31);
return binToCode(ans);
</code></pre>
<p>}<br>
void insertOffset(bool* boo, int number, int pos, int width, bool x64Ins)<br>
{<br>
if (number &gt; 0)<br>
{<br>
number = number / 16;<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
}<br>
else<br>
{<br>
number = abs(number);<br>
number = number / 16;<br>
if (!x64Ins)<br>
{<br>
number <em>= 2;<br>
}<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
boo[pos-width+1] = 1;<br>
for (int j = pos-width+2; j &lt;=pos; j++)<br>
boo[j] = boo[j] == 1 ? 0 : 1;<br>
bool up = true;<br>
for (int j = pos; j &gt; pos-width+1; j--)<br>
{<br>
if (boo[j] == 1 &amp;&amp; up)<br>
{<br>
up = true;<br>
boo[j] = 0;<br>
}<br>
else if (boo[j] == 0 &amp;&amp; up)<br>
{<br>
up = false;<br>
boo[j] = 1;<br>
}<br>
if (!up)<br>
break;<br>
}<br>
}<br>
}<br>
void insertDec(bool * boo,int number,int pos,int width)<br>
{<br>
if (number &gt; 0)<br>
{<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
}<br>
else<br>
{<br>
number = abs(number);<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
boo[pos-width+1] = 1;<br>
for (int j = pos-width+2; j &lt;=pos; j++)<br>
boo[j] = boo[j] == 1 ? 0 : 1;<br>
bool up = true;<br>
for (int j = pos; j &gt; pos-width+1; j--)<br>
{<br>
if (boo[j] == 1 &amp;&amp; up)<br>
{<br>
up = true;<br>
boo[j] = 0;<br>
}<br>
else if (boo[j] == 0 &amp;&amp; up)<br>
{<br>
up = false;<br>
boo[j] = 1;<br>
}<br>
if (!up)<br>
break;<br>
}<br>
}<br>
}<br>
void insertReg(bool</em> boo, enum registers register_, int pos)<br>
{<br>
int reg=int(register_);<br>
int loop = 5;<br>
while (loop != 0 &amp;&amp; reg != 0)<br>
{<br>
boo[pos--] = reg % 2;<br>
reg /= 2;<br>
loop--;<br>
}<br>
}<br>
uint64_t binToCode(bool* boo)<br>
{</p>
<pre><code>for (int i = 0; i &lt; 2; i++)
{
    for (int j = 0; j &lt; 8; j++)
    {
        bool temp = boo[i * 8 + j];
        boo[i * 8 + j] = boo[31 - 8 * i - (7 - j)];
        boo[31 - 8 * i - (7 - j)] = temp;
    }
}
uint64_t result = 0;
int times = 0;
for (int i = 31; i &gt;= 0; i--)
{
    result = result + boo[i] * uint64_t(pow(2, times));
    times++;
}
return result;
</code></pre>
<p>}`</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://wfcpc.github.io/post/hello-gridea/</id>
        <link href="https://wfcpc.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>