<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arm64 Inline Hook | Gridea</title>
<link rel="shortcut icon" href="https://wfcpc.github.io/favicon.ico?v=1606282256395">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://wfcpc.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Arm64 Inline Hook | Gridea - Atom Feed" href="https://wfcpc.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="`int ret_value=0;
///构建获取寄存器输入的值
void * X0=NULL;
void * X1=NULL;
void * X2=NULL;
void * X3=NULL;
void * X4=NULL;
void *R..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://wfcpc.github.io">
  <img class="avatar" src="https://wfcpc.github.io/images/avatar.png?v=1606282256395" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Arm64 Inline Hook
            </h2>
            <div class="post-info">
              <span>
                2020-11-25
              </span>
              <span>
                17 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>`int ret_value=0;<br>
///构建获取寄存器输入的值<br>
void * X0=NULL;<br>
void * X1=NULL;<br>
void * X2=NULL;<br>
void * X3=NULL;<br>
void * X4=NULL;<br>
void *RETVALUE=NULL;<br>
void getRegisters(uint64_t x0,uint64_t x1,uint64_t x2,uint64_t x3,uint64_t x4)<br>
{<br>
static uint64_t arg1=x0;<br>
static uint64_t arg2=x1;<br>
static uint64_t arg3=x2;<br>
static uint64_t arg4=x3;<br>
static uint64_t arg5=x4;<br>
X0=(void *)&amp;arg1;<br>
X1=(void *)&amp;arg2;<br>
X2=(void *)&amp;arg3;<br>
X3=(void *)&amp;arg4;<br>
X4=(void <em>)&amp;arg5;<br>
}<br>
///<br>
uint64_t setRegisters(void * address,uint64_t x0,uint64_t x1,uint64_t x2,uint64_t x3,uint64_t x4)<br>
{<br>
x0=</em>(uint64_t <em>)X0;<br>
x1=</em>(uint64_t <em>)X1;<br>
x2=</em>(uint64_t <em>)X2;<br>
x3=</em>(uint64_t <em>)X3;<br>
x4=</em>(uint64_t *)X4;<br>
#if defined(<strong>aarch64</strong>)<br>
LOGI(&quot;defined __aarch64 __ running&quot;);<br>
<strong>asm</strong>(&quot;ldr x0,[sp,#0x28]&quot;);<br>
<strong>asm</strong>(&quot;ldr x1,[sp,#0x20]&quot;);<br>
<strong>asm</strong>(&quot;ldr x2,[sp,#0x18]&quot;);<br>
<strong>asm</strong>(&quot;ldr x3,[sp,#0x10]&quot;);<br>
<strong>asm</strong>(&quot;ldr x4,[sp,#0x8]&quot;);<br>
<strong>asm</strong>(&quot;add sp,sp,#0x40&quot;);<br>
<strong>asm</strong>(&quot;mov x16,x0&quot;);<br>
uint64_t addr=(uint64_t)address;<br>
<strong>asm</strong>(&quot;mov x17,x0&quot;);<br>
<strong>asm</strong>(&quot;mov x0,x16&quot;);<br>
<strong>asm</strong>(&quot;ldp x29,x30,[sp],#0x50&quot;);<br>
<strong>asm</strong>(&quot;blr x17&quot;);<br>
<strong>asm</strong>(&quot;ret&quot;);<br>
#endif<br>
}</p>
<p>uint64_t (*template_func)();<br>
void getRetRegister(uint64_t x0)<br>
{<br>
static uint64_t ret_value=x0;<br>
RETVALUE=(void *)&amp;ret_value;<br>
}<br>
uint64_t getRetValue()<br>
{<br>
return <em>(uint64_t</em>)RETVALUE;<br>
}</p>
<p>class Space<br>
{<br>
public:<br>
uint64_t *array;<br>
int count=0;<br>
unsigned int lenght;<br>
Space(unsigned int len)<br>
{<br>
this-&gt;lenght=len;<br>
array=(uint64_t *)malloc(sizeof(uint64_t)*len);<br>
}</p>
<pre><code>void emit(uint64_t code)
{
    array[this-&gt;count++]=code;
}
void emitAtAddress(uint64_t *address)
{
    for(int i=0;i&lt;lenght;i++)
    {
        address[i]=array[i];
    }
}
uint64_t *getCodeAddress()
{
    return (uint64_t *)array;
}
</code></pre>
<p>};<br>
uint64_t backup_codes[4]={0};<br>
//uint64_t trampoline[100]={0};<br>
int num=0;<br>
enum registers<br>
{<br>
q0=0,<br>
q1=1,<br>
q2=2,<br>
q3=3,<br>
q4=4,<br>
q5=5,<br>
q6=6,<br>
q7=7,<br>
q8=8,<br>
q9=9,<br>
q10=10,<br>
q11=11,<br>
q12=12,<br>
q13=13,<br>
q14=14,<br>
q15=15,<br>
x0=0,<br>
x1=1,<br>
x2=2,<br>
x3=3,<br>
x4=4,<br>
x5=5,<br>
x6=6,<br>
x7=7,<br>
x8=8,<br>
x9=9,<br>
x10=10,<br>
x11=11,<br>
x12=12,<br>
x13=13,<br>
x14=14,<br>
x15=15,<br>
x16=16,<br>
x17=17,<br>
x18=18,<br>
x19=19,<br>
x20=20,<br>
x21=21,<br>
x22=22,<br>
x23=23,<br>
x24=24,<br>
x25=25,<br>
x26=26,<br>
x27=27,<br>
x28=28,<br>
fp=29,//fp<br>
lr=30,//lr<br>
sp=31,<br>
};<br>
uint64_t stp(int8_t imm, enum registers rt2, enum registers rn, enum registers rt1, bool x64Ins);<br>
void emit(uint64_t code);<br>
void insertOffset(bool* boo, int number, int pos, int width, bool x64Ins);<br>
void insertReg(bool* boo, enum registers register_, int pos);<br>
uint64_t binToCode(bool* boo);<br>
void insertDec(bool * boo,int number,int pos,int width);<br>
uint64_t add(uint16_t imm,enum registers rn,enum registers rd);<br>
uint64_t sub(uint16_t imm,enum registers rn,enum registers rd);<br>
uint64_t movX16NZCV();<br>
uint64_t movNZCVX16();<br>
uint64_t mov(uint16_t imm,enum registers rn,enum registers rd,bool x64Ins);<br>
uint64_t ldrImmi(uint32_t offset, enum registers rt, bool x64Ins);<br>
uint64_t br(enum registers rn);<br>
uint64_t  blr(enum registers rn);<br>
uint64_t ldp(int8_t imm,enum registers rt2,enum registers rn,enum registers rt1,bool x64Ins);<br>
uint64_t ret();<br>
void Save_codes(void *address);<br>
void BuildTrampoline(Space t,uint64_t * before_addr,uint64_t *after_addr);<br>
void BuildBeforeFunc(Space before,uint64_t * addr1,uint64_t * addr2,uint64_t *addr3);<br>
void hookfun(Space func,uint64_t *address_1);<br>
void BuildAfterFunc(Space after,uint64_t * addr1,uint64_t * addr2);<br>
void wfcpc_arm64_inline_hook(void *address, void *replace, void **backup)<br>
{<br>
//template_func=getRetT;<br>
template_func=getRetValue;<br>
auto *t_a=(void **)&amp;template_func;<br>
auto *t_b=*t_a;<br>
auto *b_a=*backup;<br>
b_a=t_b;<br>
//init<br>
Save_codes(address);</p>
<pre><code>Space func(8);
Space t(100);//跳板
uint64_t *t_addr=t.getCodeAddress();
Space before(100);
uint64_t *before_addr=before.getCodeAddress();
Space after(100);
uint64_t *after_addr=after.getCodeAddress();
hookfun(func,t_addr);//
func.emitAtAddress((uint64_t *)address);

BuildTrampoline(t,before_addr,after_addr);//构建跳板

uint64_t *beforeAddr1=(uint64_t *)getRegisters;
uint64_t *beforeAddr2=t.getCodeAddress()+0xC;
uint64_t *beforeAddr3=(uint64_t *)address+0x14;
BuildBeforeFunc(before,beforeAddr1,beforeAddr2,beforeAddr3);//构建hook函数执行前
//setRegisters
uint64_t *afterAddr1=(uint64_t *)getRetRegister;
uint64_t *afterAddr2=(uint64_t *)setRegisters;
BuildAfterFunc(after,afterAddr1,afterAddr2);//构建hook函数执行后
</code></pre>
<p>}<br>
void Save_codes(void *address)<br>
{<br>
uint64_t *code_addr=(uint64_t *)address;<br>
for(int i=0;i&lt;4;i++)<br>
{<br>
backup_codes[i]=code_addr[i];<br>
}<br>
}<br>
void hookfun(Space func,uint64_t *address_1)<br>
{<br>
//func.emit(stp(-0x20,x17,sp,x16,false));//入栈x16,x17 sp-0x10<br>
func.emit(ldrImmi(2,x16,true));<br>
func.emit(br(x16));<br>
func.emit((uint64_t)address_1);//before hook stub address</p>
<pre><code>//func.emit(ldp(-0x10,x17,sp,x16,false));
//24字节
//arm64 调试普通程序 尝试通过ret返回，返回到原程序地址
</code></pre>
<p>}<br>
void BuildTrampoline(Space t,uint64_t * before_addr,uint64_t *after_addr)<br>
{<br>
t.emit(ldrImmi(2,x16,true));<br>
t.emit(br(x16));<br>
t.emit(uint64_t(before_addr));//jmp before</p>
<pre><code>//保存x16,x17,恢复lr

t.emit(ldp(0x0,lr,sp,x16, false));
t.emit(add(0x10,sp,sp));
//sp恢复完全正常
t.emit(ldrImmi(2,x16,true));
t.emit(br(x16));
t.emit(uint64_t(after_addr));
</code></pre>
<p>}<br>
void BuildAfterFunc(Space after,uint64_t * addr1,uint64_t * addr2)<br>
{</p>
<pre><code>after.emit(movX16NZCV());
after.emit(sub(0xf0,sp,sp));

after.emit(stp(0x0,x1,sp,x1, false));//warning for x0
after.emit(stp(0x10,x3,sp,x2, false));
after.emit(stp(0x20,x5,sp,x4, false));
after.emit(stp(0x30,x7,sp,x6, false));
after.emit(stp(0x40,x9,sp,x8, false));
after.emit(stp(0x50,x11,sp,x10, false));
after.emit(stp(0x60,x13,sp,x12, false));
after.emit(stp(0x70,x15,sp,x14, false));
after.emit(stp(0x80,x18,sp,x16, false));
after.emit(stp(0x90,x20,sp,x19, false));
after.emit(stp(0xA0,x22,sp,x21, false));
after.emit(stp(0xB0,x24,sp,x23, false));
after.emit(stp(0xC0,x26,sp,x25, false));
after.emit(stp(0xD0,x28,sp,x27, false));
after.emit(stp(0xE0, lr, sp, fp, false));

after.emit(sub(0x80,sp,sp));

after.emit(stp(0x00,q1,sp,q0,true));
after.emit(stp(0x20,q3,sp,q2,true));
after.emit(stp(0x40,q5,sp,q4,true));
after.emit(stp(0x60,q7,sp,q6,true));

after.emit(ldrImmi(27,x16,true));
after.emit(blr(x16));
after.emit(ldrImmi(27,x16,true));
after.emit(blr(x16));

after.emit(ldp(0x00,q1,sp,q0,true));
after.emit(ldp(0x20,q3,sp,q2,true));
after.emit(ldp(0x40,q5,sp,q4,true));
after.emit(ldp(0x60,q7,sp,q6,true));

after.emit(add(0x80,sp,sp));

after.emit(ldp(0x0,x1,sp,x1, false));//warning for x0
after.emit(ldp(0x10,x3,sp,x2, false));
after.emit(ldp(0x20,x5,sp,x4, false));
after.emit(ldp(0x30,x7,sp,x6, false));
after.emit(ldp(0x40,x9,sp,x8, false));
after.emit(ldp(0x50,x11,sp,x10, false));
after.emit(ldp(0x60,x13,sp,x12, false));
after.emit(ldp(0x70,x15,sp,x14, false));
after.emit(ldp(0x80,x18,sp,x16, false));
after.emit(ldp(0x90,x20,sp,x19, false));
after.emit(ldp(0xA0,x22,sp,x21, false));
after.emit(ldp(0xB0,x24,sp,x23, false));
after.emit(ldp(0xC0,x26,sp,x25, false));
after.emit(ldp(0xD0,x28,sp,x27, false));
after.emit(ldp(0xE0, lr, sp, fp, false));

after.emit(add(0xf0,sp,sp));

after.emit(movNZCVX16());
//after.emit(add(0x10,sp,sp));
after.emit(ret());
after.emit(uint64_t(addr1));//getRet
after.emit(uint64_t(addr2));//after func address
</code></pre>
<p>}<br>
void BuildBeforeFunc(Space before,uint64_t * addr1,uint64_t * addr2,uint64_t *addr3)<br>
{<br>
//before.emit(sub(0x20,sp,sp));<br>
before.emit(movX16NZCV());</p>
<pre><code>before.emit(sub(0xf0,sp,sp));

before.emit(stp(0x0,x1,sp,x0, false));
before.emit(stp(0x10,x3,sp,x2, false));
before.emit(stp(0x20,x5,sp,x4, false));
before.emit(stp(0x30,x7,sp,x6, false));
before.emit(stp(0x40,x9,sp,x8, false));
before.emit(stp(0x50,x11,sp,x10, false));
before.emit(stp(0x60,x13,sp,x12, false));
before.emit(stp(0x70,x15,sp,x14, false));
before.emit(stp(0x80,x18,sp,x16, false));
before.emit(stp(0x90,x20,sp,x19, false));
before.emit(stp(0xA0,x22,sp,x21, false));
before.emit(stp(0xB0,x24,sp,x23, false));
before.emit(stp(0xC0,x26,sp,x25, false));
before.emit(stp(0xD0,x28,sp,x27, false));
before.emit(stp(0xE0, lr, sp, fp, false));

before.emit(sub(0x80,sp,sp));

before.emit(stp(0x00,q1,sp,q0,true));
before.emit(stp(0x20,q3,sp,q2,true));
before.emit(stp(0x40,q5,sp,q4,true));
before.emit(stp(0x60,q7,sp,q6,true));

before.emit(mov(0,sp,x17,false));

before.emit(ldrImmi(29,x16,true));
before.emit(blr(x16));

before.emit(ldp(0x00,q1,sp,q0,true));
before.emit(ldp(0x20,q3,sp,q2,true));
before.emit(ldp(0x40,q5,sp,q4,true));
before.emit(ldp(0x60,q7,sp,q6,true));

before.emit(add(0x80,sp,sp));

before.emit(ldp(0x0,x1,sp,x0, false));
before.emit(ldp(0x10,x3,sp,x2, false));
before.emit(ldp(0x20,x5,sp,x4, false));
before.emit(ldp(0x30,x7,sp,x6, false));
before.emit(ldp(0x40,x9,sp,x8, false));
before.emit(ldp(0x50,x11,sp,x10, false));
before.emit(ldp(0x60,x13,sp,x12, false));
before.emit(ldp(0x70,x15,sp,x14, false));
before.emit(ldp(0x80,x18,sp,x16, false));
before.emit(ldp(0x90,x20,sp,x19, false));
before.emit(ldp(0xA0,x22,sp,x21, false));
before.emit(ldp(0xB0,x24,sp,x23, false));
before.emit(ldp(0xC0,x26,sp,x25, false));
before.emit(ldp(0xD0,x28,sp,x27, false));
before.emit(ldp(0xE0, lr, sp, fp, false));

before.emit(add(0xf0,sp,sp));

before.emit(movNZCVX16());


before.emit(sub(0x10,sp,sp));
before.emit(stp(0,lr,sp,x0,false));//x0和lr入栈保存原程序返回地址
//此时栈中保存这最开始保存的x16,x17
//刚刚入栈的x0和lr
//lr x0 &lt;&lt;------sp_now-0x10

before.emit(ldrImmi(5,lr,true));
before.emit(ldrImmi(6,x16, true));
before.emit(br(x16));//29
before.emit((uint64_t)addr1);//addr to before func
before.emit((uint64_t)addr2);//save lr to after
before.emit((uint64_t)addr3);//address back to program+offset
</code></pre>
<p>}<br>
uint64_t ret()<br>
{<br>
return 0xC0035FD6;<br>
}<br>
uint64_t  blr(enum registers rn)<br>
{<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=1;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=1;
ans[i++]=1;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
ans[i++]=1;
ans[i++]=1;

ans[i++]=1;
ans[i++]=1;
ans[i++]=1;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
insertReg(ans,rn,26);
i=27;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
</code></pre>
<p>}<br>
uint64_t br(enum registers rn)<br>
{<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=1;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=1;
ans[i++]=1;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=1;
ans[i++]=1;
ans[i++]=1;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=0;
ans[i++]=0;
insertReg(ans,rn,26);
i=27;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t ldrImmi(uint32_t offset, enum registers rt, bool x64Ins)<br>
{<br>
int immi=int(offset);<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=0;<br>
ans[i++]=x64Ins;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=1;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
insertDec(ans,immi,26,19);
insertReg(ans,rt,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t mov(uint16_t imm,enum registers rn,enum registers rd,bool x64Ins)<br>
{<br>
int immi=int(imm);<br>
bool ans[32]={0};<br>
int i=0;<br>
ans[i++]=x64Ins;<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=0;
insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t movX16NZCV()<br>
{<br>
return 0x10423BD5;<br>
}<br>
uint64_t movNZCVX16()<br>
{<br>
return 0x10421BD5;<br>
}<br>
uint64_t add(uint16_t imm,enum registers rn,enum registers rd)<br>
{<br>
bool sf=1,sh=0;<br>
int immi=int(imm);<br>
bool ans[32] = {0};<br>
int i=0;<br>
ans[i++]=sf;<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=sh;

insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t sub(uint16_t imm,enum registers rn,enum registers rd)<br>
{<br>
bool sf=1,sh=0;<br>
int immi=int(imm);<br>
bool ans[32] = {0};<br>
int i=0;<br>
ans[i++]=sf;<br>
ans[i++]=1;<br>
ans[i++]=0;<br>
ans[i++]=1;</p>
<pre><code>ans[i++]=0;
ans[i++]=0;
ans[i++]=0;
ans[i++]=1;

ans[i++]=0;
ans[i++]=sh;

insertDec(ans,immi,21,12);
insertReg(ans,rn,26);
insertReg(ans,rd,31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t stp(int8_t imm, enum registers rt2, enum registers rn, enum registers rt1, bool x64Ins)<br>
{<br>
int immi = int(imm);<br>
bool ans[32] = {0};<br>
int i = 0;<br>
if (x64Ins)<br>
{<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
ans[i++] = 1;<br>
ans[i++] = 1;<br>
ans[i++] = 0;<br>
}<br>
else<br>
{</p>
<pre><code>    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 0;
    ans[i++] = 0;
    ans[i++] = 1;
    ans[i++] = 1;
    ans[i++] = 0;
}
insertOffset(ans, immi, 16, 7, x64Ins);
insertReg(ans,rt2,21);
insertReg(ans, rn, 26);
insertReg(ans, rt1, 31);
return binToCode(ans);
</code></pre>
<p>}<br>
uint64_t ldp(int8_t imm,enum registers rt2,enum registers rn,enum registers rt1,bool x64Ins)<br>
{<br>
int immi = int(imm);<br>
bool ans[32] = {0};<br>
int i = 0;<br>
if(x64Ins)<br>
ans[i++]=1;<br>
else<br>
ans[i++]=0;<br>
ans[i++]=0;<br>
ans[i++]=1;<br>
ans[i++]=0;</p>
<pre><code>ans[i++]=1;
ans[i++]=0;
ans[i++]=0;
ans[i++]=0;

ans[i++]=1;
ans[i++]=1;

insertOffset(ans,immi,16,7,x64Ins);
insertReg(ans,rt2,21);
insertReg(ans,rn,26);
insertReg(ans,rt1,31);
return binToCode(ans);
</code></pre>
<p>}<br>
void insertOffset(bool* boo, int number, int pos, int width, bool x64Ins)<br>
{<br>
if (number &gt; 0)<br>
{<br>
number = number / 16;<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
}<br>
else<br>
{<br>
number = abs(number);<br>
number = number / 16;<br>
if (!x64Ins)<br>
{<br>
number <em>= 2;<br>
}<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
boo[pos-width+1] = 1;<br>
for (int j = pos-width+2; j &lt;=pos; j++)<br>
boo[j] = boo[j] == 1 ? 0 : 1;<br>
bool up = true;<br>
for (int j = pos; j &gt; pos-width+1; j--)<br>
{<br>
if (boo[j] == 1 &amp;&amp; up)<br>
{<br>
up = true;<br>
boo[j] = 0;<br>
}<br>
else if (boo[j] == 0 &amp;&amp; up)<br>
{<br>
up = false;<br>
boo[j] = 1;<br>
}<br>
if (!up)<br>
break;<br>
}<br>
}<br>
}<br>
void insertDec(bool * boo,int number,int pos,int width)<br>
{<br>
if (number &gt; 0)<br>
{<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
}<br>
else<br>
{<br>
number = abs(number);<br>
while (width != 0 &amp;&amp; number != 0)<br>
{<br>
boo[pos--] = number % 2;<br>
number /= 2;<br>
width--;<br>
}<br>
boo[pos-width+1] = 1;<br>
for (int j = pos-width+2; j &lt;=pos; j++)<br>
boo[j] = boo[j] == 1 ? 0 : 1;<br>
bool up = true;<br>
for (int j = pos; j &gt; pos-width+1; j--)<br>
{<br>
if (boo[j] == 1 &amp;&amp; up)<br>
{<br>
up = true;<br>
boo[j] = 0;<br>
}<br>
else if (boo[j] == 0 &amp;&amp; up)<br>
{<br>
up = false;<br>
boo[j] = 1;<br>
}<br>
if (!up)<br>
break;<br>
}<br>
}<br>
}<br>
void insertReg(bool</em> boo, enum registers register_, int pos)<br>
{<br>
int reg=int(register_);<br>
int loop = 5;<br>
while (loop != 0 &amp;&amp; reg != 0)<br>
{<br>
boo[pos--] = reg % 2;<br>
reg /= 2;<br>
loop--;<br>
}<br>
}<br>
uint64_t binToCode(bool* boo)<br>
{</p>
<pre><code>for (int i = 0; i &lt; 2; i++)
{
    for (int j = 0; j &lt; 8; j++)
    {
        bool temp = boo[i * 8 + j];
        boo[i * 8 + j] = boo[31 - 8 * i - (7 - j)];
        boo[31 - 8 * i - (7 - j)] = temp;
    }
}
uint64_t result = 0;
int times = 0;
for (int i = 31; i &gt;= 0; i--)
{
    result = result + boo[i] * uint64_t(pow(2, times));
    times++;
}
return result;
</code></pre>
<p>}`</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://wfcpc.github.io/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://wfcpc.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
